package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type Schema struct {
	Schema string   `json:"$schema"`
	ID     string   `json:"$id"`
	Year   int      `json:"year"`
	Papers []string `json:"papers"`
	Days   []Day    `json:"days"`
}

type Day struct {
	Name     string `json:"name"`
	Date     string `json:"date"`
	IsOffDay bool   `json:"isOffDay"`
}

const yearTmpl = `// Code generated by generator; DO NOT EDIT.
package internal

// Year{{ .Year }}Data contains holiday data for year {{ .Year }}
var Year{{ .Year }}Data map[string]Day

// Init{{ .Year }} initializes the holiday data for year {{ .Year }}
func Init{{ .Year }}() map[string]Day {
	data := make(map[string]Day, {{ len .Days }})
	{{- range .Days }}
	data["{{ .Date }}"] = Day{Name: "{{ .Name }}", Date: "{{ .Date }}", IsOffDay: {{ .IsOffDay }}}
	{{- end }}
	return data
}

// IsHoliday{{ .Year }} checks if a given date in {{ .Year }} is a holiday
func IsHoliday{{ .Year }}(dateStr string) (bool, string, error) {
	data := GetYearData({{ .Year }})
	if day, exists := data[dateStr]; exists {
		return day.IsOffDay, day.Name, nil
	}
	return false, "", nil
}`

const mainTmpl = `// Code generated by generator; DO NOT EDIT.
package holiday

import (
	"sync"
	"{{ .InternalPkgPath }}"
)

// Day represents a single holiday or workday entry
type Day struct {
	Name     string
	Date     string
	IsOffDay bool
}

var (
	// yearDataCache stores initialized year data
	yearDataCache sync.Map

	// yearInitFuncs maps years to their initialization functions
	yearInitFuncs = map[int]func() map[string]Day{
		{{- range .Years }}
		{{ . }}: internal.Init{{ . }},
		{{- end }}
	}
)

// GetYearData returns the holiday data for a specific year, initializing it if necessary
func GetYearData(year int) map[string]Day {
	if data, ok := yearDataCache.Load(year); ok {
		return data.(map[string]Day)
	}

	// Check if we have an init function for this year
	initFunc, ok := yearInitFuncs[year]
	if !ok {
		return nil
	}

	// Initialize the data
	data := initFunc()
	
	// Store in cache
	actualData, _ := yearDataCache.LoadOrStore(year, data)
	return actualData.(map[string]Day)
}`

func main() {
	if len(os.Args) != 3 {
		fmt.Println("Usage: generator <data-dir> <output-dir>")
		os.Exit(1)
	}

	dataDir := os.Args[1]
	outputDir := os.Args[2]

	// Read all JSON files
	files, err := os.ReadDir(dataDir)
	if err != nil {
		fmt.Printf("Error reading directory: %v\n", err)
		os.Exit(1)
	}

	years := make([]int, 0)

	// Generate year-specific files
	yearTpl := template.Must(template.New("year").Parse(yearTmpl))
	for _, file := range files {
		fileName := file.Name()
		if !strings.HasSuffix(fileName, ".json") || 
		   fileName == "schema.json" || 
		   fileName == "renovate.json" ||
		   strings.Contains(fileName, "scripts/") {
			continue
		}

		content, err := os.ReadFile(filepath.Join(dataDir, fileName))
		if err != nil {
			fmt.Printf("Error reading file %s: %v\n", fileName, err)
			continue
		}

		var schema Schema
		if err := json.Unmarshal(content, &schema); err != nil {
			fmt.Printf("Error unmarshaling file %s: %v\n", fileName, err)
			continue
		}

		years = append(years, schema.Year)

		// Generate year-specific file
		yearFile := filepath.Join(outputDir, fmt.Sprintf("year_%d.go", schema.Year))
		f, err := os.Create(yearFile)
		if err != nil {
			fmt.Printf("Error creating year file %s: %v\n", yearFile, err)
			continue
		}

		if err := yearTpl.Execute(f, schema); err != nil {
			fmt.Printf("Error executing year template for %d: %v\n", schema.Year, err)
			f.Close()
			continue
		}
		f.Close()
	}

	// Generate main file
	mainFile := filepath.Join(outputDir, "holiday.go")
	f, err := os.Create(mainFile)
	if err != nil {
		fmt.Printf("Error creating main file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	mainTpl := template.Must(template.New("main").Parse(mainTmpl))
	if err := mainTpl.Execute(f, struct{ Years []int; InternalPkgPath string }{years, "internal"}); err != nil {
		fmt.Printf("Error executing main template: %v\n", err)
		os.Exit(1)
	}
}
